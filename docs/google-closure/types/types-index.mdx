---
sidebar_position: 0
---

import { Fail } from '@site/src/components/fail.js'
import { Todo } from '@site/src/components/todo.js'
import { Improve } from '@site/src/components/improve.js'
import { Stars } from '@site/src/components/stars.js'

# Type system
In essence GC type system is similar to Typescript. Let's now have a look at some note-worthy and strange things.

## Noteworthy

### Types are optional
It is an **optional type system**, params, variables, anything can be untyped. GCC will either infer the type or use `?` aka `unknown` type.

### Suppressing
You can [suppress](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#suppress-warninggroup1warninggroup2), but sadly you cannot suppress all warnings at a line. You can only suppress specific warnings.

### Any
There two different `any` types - **unknown (?)** and **all (*)**. Unlike typescript `any`, the represent something like the union of all possible types. **[Read more](./any-type)**.

### Extra properties allowed
Types **allow extra properties** (unlike in Typescript)

```js
/**
 * @typedef {{ name: string, year: number }}
 */
var Car;

/**
 * @type {Car}
 */
const car = {
  name: 'BMW',
  year: 2019,
  manufactureDate: new Date(), // no error
}
```

### Recursive types
To define recursive POJO types, use `@record`

```js
/**
* @record
*/
function MyNode() {}
/**
* @type {MyNode|null}
*/
MyNode.prototype.next;

/**
* @type {MyNode}
*/
const node = {
  next: {
    next: {
      next: null,
    },
  }
}
```

<Todo>There is no documentation on this, only this issue https://github.com/google/closure-compiler/issues/2011</Todo>

### Nullable types
Explicitly **Nullable** types have syntax `?number`, **undefinable types do not exist**.

*Sadly this syntax is exactly the opposite of Typescript where `?number` means that it is undefinable and nullable types do not exist.*

### Undefinable params
**Undefinable params** have this syntax `@param {string=} text`.

To have both nullable and undefinable use `@param {?string=} text`

### Optional properties
If you want to **leave out** some properties of an object (e.g. when passing config), the syntax is the following

```js
/**
 * @type {{
 *  bandwidth: (string|undefined)
 * }}
 */
const config = {}
```

### Untyped variables
**Untyped variables** are type checked but they have [**dynamic type**](https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System#declared-versus-inferred-types). GCC infers the type correctly, but you can change it.
```js
let x = 111 // GCC know it is number
x = 'hello' // GCC know it is string
```

### Read-only attributes
Read-only attributes

```js
class Car {
  constructor() {
    /**
     * @const
    */
    this.name = 'Car';
  }
}

new Car().name = 'car 2' // produces error
```

### Object type
**`Object`** type represents union of all Object-based types (Function, Array, Map, Set, Element, etc.). It is similar to `*` if you subtract primitive types from it (number, string, etc).

### Safe old-style classes
If you are using old-style class syntax, make sure to use [`@struct`](https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations) to add some extra type safety. It makes sure you do not define additional attributes on the fly.

New-style class syntax is type safe by default.

```js
/**
 * @constructor
 */
function Car() {}

new Car().name = 'Tesla';
```

```js
/**
 * @constructor
 * @struct
 */
function Car() {}

new Car().name = 'Tesla'; // produces error
```



## Strange and wrong

### Record type syntax is strange
Syntax of `@typedef` is [strange](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#typedef-type)
```js
/** 
 * @typedef {{
 *            foo:string,
 *            bar:number,
 *            foobar: (number|string)
 *          }}
 */
var Mytype;
```

### Record Types allow access to undeclared attributes
Record types allow access to undeclared attributes

```js
/**
 * @type {{ name: string }}
 */
const x = {
  name: 'hello',
}

x.surname = 'xxxx'
```

*This cannot be fixed with @struct, only with strictMissingProperties flag.*

### 2D array syntax sucks
2D arrays `T[][]` are not supported, you must use ```Array<Array<T>>``` instead

### No literal types
GC does not have string/number literal type, such as:

```js
/**
 * @type {'apple'} // Produces error, unsupported type
 */
const fruit = 'apple'
```

This leads to a bigger problem, that I cannot use label-based conditions on POJOs, which is a common thing to do in Typescript. Actually you can do it here, but only via type casting.

```js
/**
 * @param {{ type: 'orange', height: number } | { type: 'apple', age: number }} fruit
*/
function eat(fruit) {
  if (fruit.type === 'apple') {
    // ...
  }
}
```

### Generic object type fails
Generic Objects (e.g. `Object<string, number>`) [do not work](./report)

### typeof fails
`typeof` operator [does not work](./report)

### Some, and only some, types are nullable
**Some type are nullable by default.** This is a fucking joke. More specifically, primitive types are non-nullable and Object-based types are nullable. Let's see examples:

Primitive types are not nullable or undefinable
```js
/**
 * @type {number} // string, boolean
 */
const x = null // produces error
const x = undefined // produces error
```

Object-based types are nullable (but not undefinable)
```js
class Car {}
/**
 * @type {Car} // String, Boolean, Object, Array, Promise, Function, Symbol, Set, Map, Node, Element
 */
const x = null
const x = undefined // produces error
```

**As a result, you should use a ridiculous amount of `!` in your code all the time!**

```js
class Car {}
/**
  * @type {!Car} // ! specifies that type is non-nullable
  */
const x = new Car()
const x = null // produces error
```

**Record types are not nullable**, which is a good thing.
  
*Even though it may be confusing, because they literally describe and object and its attributes.*

```js
/**
 * @typedef {{
 *  id: string,
 *  name: string
 * }}
 */
var Car;

/**
 * @type {Car}
 */
const car = null; // produces error
```

### Array/Collection type-check sucks
- Arrays are [wrongly assumed to never be empty](./report)
- HTML collection is [wrongly assumed to never be empty](./report)

### DOM type check sucks
Type checking of HTML elements is a joke. In essence there is only `Element` which kind of represents a union of all HTML elements, but even that is not done very successfully.

[Read more all the details.](./dom)

### Map type-check sucks
`Map.get()` is wrongly assumed to [never return undefined](./report)

### Unions are a mess
Union types are a [big mess](https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System#union-types). Basically they work same as set union, so instead of representing a multiple different types like in Typescript, the union type represents a single new type that has all the properties of the sub-types on it.

**Union types therefore allow many invalid things to happen.** As a rule of thumb, always cast your values to a specific type first and them work with them.

```js
/**
 * @type {string|number}
*/
let text1 = 555
const len = text1.length 

/**
 * @type {string|Array<string>}
*/
let arg = 'hello'
arg.filter(Boolean)
```

As an added bonus to add to all the mess, [union types sometimes convert attributes to unknown (?)](.report) type. As in this example:

```js
/**
 * @typedef {{ name: string} | {age: number, name: string}}
 */
var Car;

/**
 * @type {Car}
 */
const car = { name: 'BMW'}
car.age.toUpperCase() // should error, because car.age is a number
```

### No arrow function types
Arrow function types are not supported, to type a callback use `function` syntax

```js
/**
 * Supported:
* @type {function(string): string}
*/
let pasteText = text => text

/**
 * Not supported:
* @type {string => string}
* @type {(x: string) => string}
*/
```

### No union of callbacks or function overloading types
Union of callback types is not supported. This means that **function/method overloading is not supported** either.

```js
/**
 * @type {function(string): string|function(number): number} // is equivalent to @type {function(?): ?}
*/
let cutText = function(text) {
  return text
}

/**
 * @type {number}
*/
const value = cutText(new Date()) // No error is produced neither left nor right
```

### Interfaces are ugly

**Interfaces**, let's break it down:

`@interface` must be used hand in hand with `@implements`. You can use old syntax


```js
/** @interface */
function ISerializable() {};
/** @type {function(): string} */
ISerializable.prototype.serialize;
/** @type {function(string): *} */
ISerializable.prototype.deserialize;

/**
 * @implements {ISerializable}
* @constructor
*/
function Car() {}
// produces error because .serialize() and .deserialize() are not defined

/**
* @implements {ISerializable}
* @constructor
*/
function Car() {}
Car.prototype.serialize = function() { return 555 }; // produces error, wrong return type
/**
* @param {boolean} ok
*/
Car.prototype.deserialize = function(ok) { }; // produces error wrong param type
```

Or you can use new syntax

```js
/** @interface */
class ISerializable {}
/**
* @type {string}
*/
ISerializable.prototype.id;
/**
* @type {function(): string}
*/
ISerializable.prototype.serialize;

/**
* @implements {ISerializable}
*/
class Car {
  constructor() {
    this.id = 'car';
  }

  serialize() {
    return 'my car'
  }
}
```

**Careful**, there is a bug, if you never call `return` in a method, then return value is [**not checked**](./report).

It is possible to use **`@record`**, which behaves like a Typescript `interface` and does not need the corresponding `@implements`, but `@interface` is preferred, because [`@interface` produces better code optimization](https://github.com/google/closure-compiler/wiki/Structural-Interfaces-in-Closure-Compiler#use-of-interface-is-preferred-to-record-when-possible).

<Todo>It is a pity that the new syntax is not documented anywhere!</Todo>

### Typedefs fail with recursion

Typedefs (or *record types*) do not support recursion but instead of error, the recursive attribute [just gets converted to `?` type](./report).

### Visibility

Class methods and attributes can be marked `@private`, `@protected`, but works a bit strange. In addition to working as expected, the private/protected attributes and methods can also be **accessed anywhere within the file where the class is defined.**

```js
export class Car {
  constructor() {
    /**
     * @private
     */
    this.color = 'red';
  }
}

const car = new Car().color = 'blue' // ok. It is in the same file
```

### Window type
GCC does type-checking of window so it knows `Window` type. However, I have [not found it documented anywhere](./report)





## Compiler flags
The strictness of the compiler can be configured and by default it is not as strict as it could be. Sadly the [compiler flags are a big mess and frequently do not work](./compiler-flags).

I recommend enabling:
```bash
--jscomp_error=checkDebuggerStatement \
--jscomp_error=unusedLocalVariables \
--jscomp_error=reportUnknownTypes \ # ideally
```

### Strict type checking
`strictCheckTypes` gives you strict type checking, however, [I have concluded that it works only when you do not work with the DOM](./strict-checks).


## TODO
1. here externs https://github.com/google/closure-compiler/wiki/How-do-I-make-closure-compiler-stop-breaking-my-API-by-removing-and-renaming-things%3F are documented, but I haven't found this when I was looking for it, it needs a link in wiki!
2. https://github.com/google/closure-compiler/wiki/Conformance:-Sources-of-%22unknown%22
