---
sidebar_position: 0
---

import { Fail } from '@site/src/components/fail.js'
import { Todo } from '@site/src/components/todo.js'
import { Improve } from '@site/src/components/improve.js'
import { Stars } from '@site/src/components/stars.js'

# Type system
In essence GC type system is similar to Typescript. Let's now have a look at some note-worthy and strange things.

## Noteworthy

### Types are optional
It is an **optional type system**, params, variables, anything can be untyped. GCC will either infer the type or use `?` aka `unknown` type.

### Suppressing
You can [suppress](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#suppress-warninggroup1warninggroup2) errors and warnings, but sadly you cannot suppress all at a line/file. You have to be specific.

It is pretty complicated to suppress and error. GCC gives you error codes, but you cannot suppress them, you have to find an error group that contains this code and suppress the group instead. [Here is a list of all the error groups](https://github.com/google/closure-compiler/wiki/@suppress-annotations).

### Any
There two different `any` types - **unknown (?)** and **all (*)**. Unlike typescript `any`, the represent something like the union of all possible types. **[Read more](./any-type)**.

### Extra properties allowed
Types **allow extra properties** (unlike in Typescript)

```js
/**
 * @typedef {{ name: string, year: number }}
 */
var Car;

/**
 * @type {Car}
 */
const car = {
  name: 'BMW',
  year: 2019,
  manufactureDate: new Date(), // no error
}
```

### Recursive types
To define recursive POJO types, use `@record`

```js
/**
* @record
*/
function MyNode() {}
/**
* @type {MyNode|null}
*/
MyNode.prototype.next;

/**
* @type {MyNode}
*/
const node = {
  next: {
    next: {
      next: null,
    },
  }
}
```


### Interfaces

Old syntax

```js
/** @interface */
function ISerializable() {};
/** @type {function(): string} */
ISerializable.prototype.serialize;
/** @type {function(string): *} */
ISerializable.prototype.deserialize;

/**
* @implements {ISerializable}
* @constructor
*/
function Car() {}
Car.prototype.serialize = function() { return 555 }; // produces error, wrong return type
/**
* @param {boolean} ok
*/
Car.prototype.deserialize = function(ok) { }; // produces error wrong param type
```

New syntax

```js
/**
 * @interface
 */
class ISerializable {
  constructor() {
    /** @type {string} */
    this.id;
  }
  
  /**
   * @returns {string}
   */
  serialize() {}
}

/**
 * @implements {ISerializable}
 */
class Car {
  constructor() {
    this.id = 'FJS904328JS';
  }

  serialize() {
    return '{ "id": "FJS904328JS"}'
  }
}

```

**Careful**, there is a bug, if you never call `return` in a method, then return value is [**not checked**](./report).

It is possible to use **`@record`**, which behaves like a Typescript `interface` and does not need the corresponding `@implements`, but `@interface` is preferred, because [`@interface` produces better code optimization](https://github.com/google/closure-compiler/wiki/Structural-Interfaces-in-Closure-Compiler#use-of-interface-is-preferred-to-record-when-possible).


### Nullable types
Explicitly **Nullable** types have syntax `?number`, **undefinable types do not exist**.

*Sadly this syntax is exactly the opposite of Typescript where `?number` means that it is undefinable and nullable types do not exist.*

### Undefinable params
**Undefinable params** have this syntax `@param {string=} text`.

To have both nullable and undefinable use `@param {?string=} text`

### Optional properties
If you want to **leave out** some properties of an object (e.g. when passing config), the syntax is the following

```js
/**
 * @type {{
 *  bandwidth: (string|undefined)
 * }}
 */
const config = {}
```

### Untyped variables
**Untyped variables** are type checked but they have [**dynamic type**](https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System#declared-versus-inferred-types). GCC infers the type correctly, but you can change it.
```js
let x = 111 // GCC know it is number
x = 'hello' // GCC know it is string
```

### Read-only attributes
Read-only attributes

```js
class Car {
  constructor() {
    /**
     * @const
    */
    this.name = 'Car';
  }
}

new Car().name = 'car 2' // produces error
```

### Object type
**`Object`** type represents union of all Object-based types (Function, Array, Map, Set, Element, etc.). It is similar to `*` if you subtract primitive types from it (number, string, etc).

### Safe old-style classes
If you are using old-style class syntax, make sure to use [`@struct`](https://github.com/google/closure-compiler/wiki/@struct-and-@dict-Annotations) to add some extra type safety. It makes sure you do not define additional attributes on the fly.

New-style class syntax is type safe by default.

```js
/**
 * @constructor
 */
function Car() {}

new Car().name = 'Tesla';
```

```js
/**
 * @constructor
 * @struct
 */
function Car() {}

new Car().name = 'Tesla'; // produces error
```

### Try catch
[Type-checking catch is straight forward](https://github.com/google/closure-compiler/wiki/Annotating-Types#catch-declarations). If you know the type:

```js
try {
  parseFloat('hello')
} catch (/** @type {Error} */ error) {
  console.error(error.message)
}
```
If you don't know the type:
```js
try {
  parseFloat('hello')
} catch (/** @type {*} */ error) {
  console.error(error)
}
```












## Strange and wrong

### Record type syntax is strange
Syntax of `@typedef` is [strange](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#typedef-type)
```js
/** 
 * @typedef {{
 *            foo:string,
 *            bar:number,
 *            foobar: (number|string)
 *          }}
 */
var Mytype;
```

### Record Types allow access to undeclared attributes
Record types allow access to undeclared attributes

```js
/**
 * @type {{ name: string }}
 */
const x = {
  name: 'hello',
}

x.surname = 'xxxx'
```

*This cannot be fixed with @struct, only with strictMissingProperties flag.*

### 2D array syntax sucks
2D arrays `T[][]` are not supported, you must use ```Array<Array<T>>``` instead

### No literal types
GC does not have string/number literal type, such as:

```js
/**
 * @type {'apple'} // Produces error, unsupported type
 */
const fruit = 'apple'
```

This leads to a bigger problem, that I cannot use label-based conditions on POJOs, which is a common thing to do in Typescript. Actually you can do it here, but only via type casting.

```js
/**
 * @param {{ type: 'orange', height: number } | { type: 'apple', age: number }} fruit
*/
function eat(fruit) {
  if (fruit.type === 'apple') {
    // ...
  }
}
```

### Generic object type fails
Generic Objects (e.g. `Object<string, number>`) [do not work](./report)

### typeof is useless
`typeof` operator does not work as expected. [Apparently you can only use it on a namespace and I do not even know what that means.](https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System)

### Some, and only some, types are nullable
**Some type are nullable by default.** This is a fucking joke. More specifically, primitive types are non-nullable and Object-based types are nullable. Let's see examples:

Primitive types are not nullable or undefinable
```js
/**
 * @type {number} // string, boolean
 */
const x = null // produces error
const x = undefined // produces error
```

Object-based types are nullable (but not undefinable)
```js
class Car {}
/**
 * @type {Car} // String, Boolean, Object, Array, Promise, Function, Symbol, Set, Map, Node, Element
 */
const x = null
const x = undefined // produces error
```

**As a result, you should use a ridiculous amount of `!` in your code all the time!**

```js
class Car {}
/**
  * @type {!Car} // ! specifies that type is non-nullable
  */
const x = new Car()
const x = null // produces error
```

**Record types are not nullable**, which is a good thing.
  
*Even though it may be confusing, because they literally describe and object and its attributes.*

```js
/**
 * @typedef {{
 *  id: string,
 *  name: string
 * }}
 */
var Car;

/**
 * @type {Car}
 */
const car = null; // produces error
```

### Array/Collection type-check sucks
- Arrays are [wrongly assumed to never be empty](./report)
- HTML collection is [wrongly assumed to never be empty](./report)

### Arrays have some problems with type checking
Array literals are not type checked!

```js
// GCC does not know this is array of number
[-1,0,1,2,3,4]
```

`Array.reduce` is not type checked at all.


### DOM type check sucks
In short DOM type checking only starts to work correctly when `strictCheckTypes` compiler flag is enabled. Then is is pretty fine, not perfect, but fine.

[Read more all the details.](./dom)

### Map type-check sucks
`Map.get()` is wrongly assumed to [never return undefined](./report)

### Unions are a mess
Union types are a [big mess](https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System#union-types). Basically they work same as set union, so instead of representing a multiple different types like in Typescript, the union type represents a single new type that has all the properties of the sub-types on it.

**Union types therefore allow many invalid things to happen.** As a rule of thumb, always cast your values to a specific type first and them work with them.

```js
/**
 * @type {string|number}
*/
let text1 = 555
const len = text1.length 

/**
 * @type {string|Array<string>}
*/
let arg = 'hello'
arg.filter(Boolean)
```

As an added bonus to add to all the mess, [union types sometimes convert attributes to unknown (?)](.report) type. As in this example:

```js
/**
 * @typedef {{ name: string} | {age: number, name: string}}
 */
var Car;

/**
 * @type {Car}
 */
const car = { name: 'BMW'}
car.age.toUpperCase() // should error, because car.age is a number
```

### No arrow function types
Arrow function types are not supported, to type a callback use `function` syntax

```js
/**
 * Supported:
* @type {function(string): string}
*/
let pasteText = text => text

/**
 * Not supported:
* @type {string => string}
* @type {(x: string) => string}
*/
```

### No union of callbacks or function overloading types
Union of callback types is not supported. This means that **function/method overloading is not supported** either.

```js
/**
 * @type {function(string): string|function(number): number} // is equivalent to @type {function(?): ?}
*/
let cutText = function(text) {
  return text
}

/**
 * @type {number}
*/
const value = cutText(new Date()) // No error is produced neither left nor right
```

### Promises are not type-checked well
[Read about it here](https://github.com/google/closure-compiler/issues/4040)

```js
/**
 * @type {Promise<string>}
 */
const p = Promise.resolve() // should raise error, it resolves to undefined, not string
```

```js
/**
 * @type {Promise<string>}
 */
const p = Promise.resolve().then(function() { return 555 }) // should raise error, it resolves to number, not string
```

```js
/**
 * @type {Promise<string>}
 */
const p = new Promise((resolve, reject) => {
  resolve(666) // should raise error, it resolves to number, not string
})
```

```js
/**
 * @type {Promise<number>} // should raise error, it resolves to string, not number
 */
const p = new Promise(
  /**
   * @param {function(string): void} resolve 
   * @param {function(string): void} reject 
   */
  (resolve, reject) => {
    resolve('Hello')
  }
)
```

### Typedefs fail with recursion

Typedefs (or *record types*) do not support recursion but instead of error, the recursive attribute [just gets converted to `?` type](./report).

### Visibility

Class methods and attributes can be marked `@private`, `@protected`, but works a bit strange. In addition to working as expected, the private/protected attributes and methods can also be **accessed anywhere within the file where the class is defined.**

```js
export class Car {
  constructor() {
    /**
     * @private
     */
    this.color = 'red';
  }
}

const car = new Car().color = 'blue' // ok. It is in the same file
```

### Spread/rest operators work only half the time
[Object spread](https://github.com/google/closure-compiler/issues/3132) and [object rest](https://github.com/google/closure-compiler/issues/4042) operators do not get type-checked correctly.

**Luckily at least rest params and array rest are type checked as they should.**
```js
/**
 * @param {...number} args 
 */
function sum(...args) {
  return args
}
```
```js
/**
 * @type {Array<number>}
 */
const arr = [1,2,3,4,5,6]
const [x, ...rest] = [1,2,3,4,5,6] // GCC understands that `rest` is Array<number>
```

### Lack of Type Utilities
Sadly the type system lacks Type Utilities (such as `ReturnType`, `Omit`, etc. see [TS type utilities](https://www.typescriptlang.org/docs/handbook/utility-types.html)). This leads to a lot more boilerplate.








## Compiler flags
The strictness of the compiler can be configured and by default it is not as strict as it could be. Sadly the [compiler flags are a big mess and frequently do not work](./warnings-config).

**I recommend enabling:**

```bash
--jscomp_error=checkDebuggerStatement \
--jscomp_error=unusedLocalVariables \
--jscomp_error=reportUnknownTypes \
--jscomp_error=strictCheckTypes
```

### Strict type checking
There are two flags vital to making sure type checking is strict and on point:

1. `strictCheckTypes` - [makes sure you can only access the attributes that are definitely defined on a type](./strict-checks). Also, union types become intersection types.
2. `reportUnknownTypes` - whenever GCC does not know the type it produces a warning (by default there is no warning)
