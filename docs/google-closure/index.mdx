---
sidebar_position: 8
---

import { Fail } from '@site/src/components/fail.js'
import { Todo } from '@site/src/components/todo.js'
import { Improve } from '@site/src/components/improve.js'
import { Stars } from '@site/src/components/stars.js'


# Google Closure
Google Closure is a stdlib, type system and compiler. Stdlib contains utils and UI. Type system is JSDoc based, so code remains valid JS. And authors claim the compiler does amazing minification, but that remains to be seen.

The documentation of GC is a big mess. Something is in official doc, something on Github, something on Discuss, something in `compiler.jar --help`.

**Root links**:
- [Official doc](https://developers.google.com/closure/compiler)
- [Github wiki](https://github.com/google/closure-compiler/wiki)
- [Google groups issues](https://groups.google.com/g/closure-compiler-discuss)
- [Github issues](https://github.com/google/closure-compiler/issues)

**Useful direct links**:
- [GCC JAR download](https://mvnrepository.com/artifact/com.google.javascript/closure-compiler)
- [List of GC type annotations](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler)
- [GC type system explained](https://github.com/google/closure-compiler/wiki#typing)
- [GC compiler flags](https://github.com/google/closure-compiler/wiki/Flags-and-Options)
- [GCC github](https://github.com/google/closure-compiler)

**TODO**
- github homepage https://github.com/google/closure-compiler
- GC blog http://closuretools.blogspot.com/2011/01/property-by-any-other-name-part-3.html

## Stdlib
<Todo>What is in there</Todo>

## Type system
The type system is based on JSDoc. In essence it resembles Typescript but [when you dive down into the details it is a big mess](./types/types-index). Sadly the type system lacks Type Utilities (such as [TS type utilities](https://www.typescriptlang.org/docs/handbook/utility-types.html).

### Type checking engine
The type checking can do a little bit of type inference, but just a little bit. It's strength is comparable to that of Flow, but it is a far cry from Typescript. Here is a [little analysis](./type-inference).

Another big problem is the lack of IDE support. There is no plugin for vscode, so you develop code and you do not know if it is valid until you run build. This can be alleviated by turning on vscode TS-powered JSDoc type checking, but it's great to be using two different type checking engines at the same time. Usually GCTE is weaker, so some code that is valid in TS is not valid in GC.

<Fail>So with every commit I make, everything looks fine in vscode, because it is fine, but GCC is not strong enough to understand the types and gives warning.</Fail>

GCC language engine performs some static analysis, but it's a far cry from modern engines such as TS.

<Fail>If language engine does not know the type of a variable there is not error, it simply compiles without warning.</Fail>

```js
/**
 * @param {number} b 
 */
function sum(a,b) {
  return a.charAt(0) + b
}
```
<Todo>TODO is there a way to enable strict mode?</Todo>


<Todo>TODO what about the lax checking of DOM attrs? + link</Todo>


## Compiler
The compiler (GCC) does type checking, tree shaking, minification and a implements support for module systems. Nothing however comes out-of-the-box, and [working with GCC CLI is a real pain](./cli-issues).

Do you want source maps? Yes, possible but I won't tell you how. Do you want minification/optimization? Yes, that is what GCC is famous for but you have to figure out how on your own. Do you want to import code from `node_modules`? Go look on stackoverflow to figure out how, and even then it will not work.

The most basic setup, just to compile a bundle is pretty complex:

```bash
java -jar ./scripts/closureCompiler.jar \
  --entry_point=./src/js/index.js \
  --js=./src/**.js \ # This glob must select all JS files that should (potentially) be in the bundle
  --js_output_file=./dist/bundle.js
```

All in all GCC seems good at compiling simple web app without dependencies but anything beyond that is a headache.

### Module systems
CJS and ESM syntax are supported out-of-the-box. GC also comes with its own `goog.provide()`, `goog.require()` modules system, which works as well.

One weird quirk is that you have to configure

```bash
java -jar ./scripts/closureCompiler.jar \
  --module_resolution=WEBPACK
```

this allows you to write imports without file extension.

```js
import { app } from './app' // not app.js
```

### Type checking
In order to run type checking configure:
```bash
java -jar ./scripts/closureCompiler.jar \
  --warning_level=VERBOSE
```

### Tree shaking
In order to enable tree-shaking configure:

```bash
java -jar ./scripts/closureCompiler.jar \
  --entry_point=./src/js/index.js \
  --dependency_mode=PRUNE \
  --output_manifest=./dist/structure.txt # This file will contain a list of all files that have been used to compile the bundle (for debug purposes)
```

### Code minification / optimization
Optimizations should provide code minification, even dead code elimination and some other optimizations.

In order to run optimizations configure:

```bash
java -jar ./scripts/closureCompiler.jar \
  --entry_point=./src/js/index.js \
  --dependency_mode=PRUNE \ # The first optimization is to enable tree shaking here
  --assume_function_wrapper=true \ # Allow more optimizations because I'm not using Window. For me this gave me (cca 50% bundle size reduction) in Fractals project. Finally GCC was able to minify all by variables
  --compilation_level=ADVANCED # Ultra minification and optimizations
```

<Fail>compilation_level=ADVANCED broke my code, don't know why. I am not doing illegal hacks and I am not even using node_modules.</Fail>

Probably because of my web worker https://developers.google.com/closure/compiler/docs/api-tutorial3. In short advanced compilation fucks up:



<Todo>If you use node_modules or external libraries. It is necessary to define externs. I do not know how yet. </Todo>


Limitations of advanced OPT:

1. You cannot mix `obj.name` and `obj['name']` property access styles
2. You cannot use `getter/setters`
3. window lib calls. If you are using a window library (e.g. `window.$()`) these calls will be renamed and will therefore fail. [Solution](https://developers.google.com/closure/compiler/docs/api-tutorial3#comptoex)
4. building a library API is not possible, your API functions/methods will be renamed, or more likely removed as unused code. [Solution](https://developers.google.com/closure/compiler/docs/api-tutorial3#extocomp)
5. Web workers also have problems - usually you send some payload to the worker, the problem is that AC changes attribute names on the object you send from main to worker (and back). (This is not documented anywhere)
6. REST APIs (and client-server communication in general) - has the same problem as web workers, AC will mangle object property names on payload that you send to server and probably there also be problems with parsing data coming from server. (This is not documented anywhere)


Less scary limitations:

1. You cannot use `Object.defineProperties`
2. You can use `this` only in prototype methods

Limitations sources:
1. https://developers.google.com/closure/compiler/docs/limitations
2. https://developers.google.com/closure/compiler/docs/api-tutorial3

### Source maps
Source maps are a very useful tool during development. Without it there is no debugging. With GCC this is ridiculously hard to set up.

```bash
java -jar ./scripts/closureCompiler.jar \
  --create_source_map=%outname%.map \
  --source_map_include_content=true \ # This includes the source files inside the source map
  --output_wrapper="%output%//# sourceMappingURL=bundle.js.map"
```

<Improve>File a bug report. I had to go on stackoverflow to find out how to do source maps. This is not normal.</Improve>

### ESNext support
GCC has a pretty good [support of ESNext features](https://github.com/google/closure-compiler/wiki/Supported-features), but it is not on par with modern engines.

‚ùå [public/private class fields are not supported](https://github.com/google/closure-compiler/issues/2731), you must define them in constructor instead! This means `arrow methods` are not supported either.

### Transpilation
<Todo>Input and output language</Todo>

### Cyclic dependencies

<Fail>GCC allows cyclic dependencies between files and there is not option to prevent them. This is a ticking time bomb. (Webpack has the same problem, but at least there is a plugin to fix that.)</Fail>

<Todo>how to prevent cycles?</Todo>


### More
<Todo>how to do polyfills</Todo>

### Using libraries
<Todo>libs</Todo>

### Creating a library
(UMD/CJS/ESM) how?

API should be defined in externs: https://developers.google.com/closure/compiler/docs/externs-and-exports
It seems that externs will not work out of the box https://developers.google.com/closure/compiler/docs/api-tutorial3 you need to suppress warnings!!! wtf!

https://github.com/google/closure-compiler/wiki/FAQ#how-do-i-write-an-externs-file


## TODO
1. Try to convert to TS JSDoc
   1. [intro](https://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html)
   2. [reference](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#unsupported-tags)
   3. List all the advantages that this will bring
   4. How to mix .ts and .jsdoc files in one build process?
2. Compare webpack and GCC
3. FAQ https://developers.google.com/closure/compiler/faq
4. polyfills
5. community https://developers.google.com/closure/compiler/community


## Bugs
1. wrong doc https://github.com/google/closure-compiler/wiki/Externs-For-Common-Libraries#introduction

### Externs

<Fail>FAQ on how to write externs does not tell you anything about how to write externs, neither does wiki</Fail>

[FAQ](https://github.com/google/closure-compiler/wiki/FAQ#how-do-i-write-an-externs-file)
[wiki](https://github.com/google/closure-compiler/wiki/Externs-For-Common-Libraries)

Official doc tells you how, but it says that it will produce [an error that needs to be suppressed](https://developers.google.com/closure/compiler/docs/externs-and-exports) and does not tell you how!


TODO how to define externs?
TODO [@noalias](https://github.com/google/closure-compiler/wiki/Annotating-JavaScript-for-the-Closure-Compiler#noalias) should be used in externs file ... why is externs file getting aliased at all?
